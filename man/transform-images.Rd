% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generics.R, R/rigid_transform.R
\name{RigidTransformImages}
\alias{RigidTransformImages}
\alias{RigidTransformImages.default}
\alias{RigidTransformImages.Seurat}
\title{Apply rigid transformations to images}
\usage{
RigidTransformImages(object, ...)

\method{RigidTransformImages}{default}(object, image, xy_coords, verbose = TRUE, ...)

\method{RigidTransformImages}{Seurat}(object, transforms, verbose = TRUE, ...)
}
\arguments{
\item{object}{An object}

\item{...}{Arguments passed to other methods}

\item{image}{an image of class `magick-image`, `raster`, `StoredSpatialImage`
or a path to an image in PNG or JPEG format}

\item{xy_coords}{spot coordinates that can be mapped to \code{image}}

\item{verbose}{print messages}

\item{transforms}{a tibble containing information about the transformations
to apply to the images (see Seurat section)}
}
\value{
A list with two elements:
\itemize{
  \item{"im_transf": An object of class `magick-image` representing the transformed image}
  \item{"xy_transf": An object of class `tble` representing the transformed coordinates}
}
}
\description{
Apply rigid transformations to images
}
\section{default method}{

Object is a tibble containing information about the image dimensions that are
matched with \code{xy_coords}. The coordinates \code{xy_coords} do not have to
match the input image as long as the image dimensions in \code{object} are matched.
This is to ensure that the coordinates can be transformed correctly regardless of the
dimensions of the \code{image}. For example, the coordinates provided by spaceranger
in "tissue_positions.csv" can be mapped to the original H&E image and therefore the
original H&E image dimensions are required to correctly specify the dimensions
when using these coordinates for plotting. Doing so, we can map the coordinates
correctly on the H&E image regardless of its size.

The required columns are:

\itemize{
  \item{\code{full_width, full_height}: the dimensions of the image that \code{xy_coords} map to}
  \item{\code{sampleID}: an integer specifying a sample ID}
  \item{\code{
     mirror_x, mirror_y}: TRUE/FALSE specifying if the image should be mirrored along
     the x- and/or y-axis
     }
  \item{\code{angle}: a numeric specifying an angle to rotate the image by in degrees}
  \item{
     \code{tr_x, tr_y}: numeric values specifying translations along the x- and/or y-axis.
     \code{tr_x, tr_y} have to be values between -1 and 1 where 0 means no translation and
     1 is equal to the image width or height. Negative values will shift the image along the axis in the
     opposite direction. For example, setting \code{tr_x = 0.5} will move the image 50% of the image width
     to the right and setting \code{tr_x = -0.5} will move the image 50% of the image width to the left
     }
}
}

\examples{

library(STUtility2)
library(tibble)

transforms <- generate_rigid_transform(mirror_x = TRUE, angle = 30, tr_x = 0.2, tr_y = -0.2)

# Combine image dimensions with transforms.
# These are the dimensions of the H&E image used as input for
# spaceranger count.
transforms <- tibble(full_width = 18107, full_height = 19242) |>
  bind_cols(transforms)
transforms
# get example coordinate file
coordinatefile <- system.file("extdata/mousebrain/spatial",
                              "tissue_positions_list.csv",
                              package = "STUtility2")

# Load coordinates
# These coordinates are defined on the H&E image used as input for
# spaceranger count.
xy <- LoadSpatialCoordinates(coordinatefiles = coordinatefile, verbose = T)
xy

# Load image
lowresimagefile <- system.file("extdata/mousebrain/spatial",
                               "tissue_lowres_image.png",
                               package = "STUtility2")
im <- image_read(lowresimagefile)

# Transform image and coordinates
transf_res <- RigidTransformImages(transforms, image = im, xy_coords = xy)

ggplot(transf_res$xy_transf, aes(tr_x, tr_y)) +
  geom_point(color = "red", alpha = 0.5) +
  geom_segment(aes(x = 0, y = 0.5*19242, xend = 0.2*18107, yend = 0.5*19242),
               arrow = arrow(length = unit(0.5, "cm"))) +
  geom_vline(xintercept = 0.2*18107, linetype = "dashed") +
  geom_segment(aes(x = 0.5*18107, y = 19242, xend = 0.5*18107, yend = 0.8*19242),
               arrow = arrow(length = unit(0.5, "cm"))) +
  geom_hline(yintercept = 0.8*19242, linetype = "dashed") +
  scale_x_continuous(limits = c(0, 18107), expand = c(0, 0)) +
  scale_y_reverse(limits = c(19242, 0), expand = c(0, 0)) +
  labs(x = expression("x"["transformed"]),
       y = expression("y"["transformed"]),
       title = "20\% right, 20\% up, 30 deg rotation") +
  theme_void() +
  theme(axis.text = element_text(),
        axis.title.x = element_text(),
        axis.title.y = element_text(angle = 90)) +
  coord_fixed() +
  # Insert H&E image
  inset_element(p = as.raster(transf_res$im_transf),
                left = 0, bottom = 0,
                right = 1, top = 1,
                on_top = FALSE)

library(STUtility2)

se_mbrain <- readRDS(system.file("extdata/mousebrain", "se_mbrain", package = "STUtility2"))
se_mcolon <- readRDS(system.file("extdata/mousecolon", "se_mcolon", package = "STUtility2"))
se_merged <- MergeSTData(se_mbrain, se_mcolon) |>
  LoadImages()

# Define rigid tranformations for section 2
transforms <- generate_rigid_transform(sampleID = 2, angle = 30, mirror_x = TRUE)

# Apply transformations
se_merged <- RigidTransformImages(se_merged, transforms = transforms)

# Plot transformed image
MapFeatures(se_merged, features = "Th", image_use = "transformed")

# Define rigid tranformations for all sections
transforms <- bind_rows(generate_rigid_transform(sampleID = 1, angle = 30, mirror_x = TRUE),
                        generate_rigid_transform(sampleID = 2, angle = 60))
# Apply transformations
se_merged <- RigidTransformImages(se_merged, transforms = transforms)

# Plot transformed image
MapFeatures(se_merged, features = "Th", image_use = "transformed")

}
\seealso{
Other image transformations: 
\code{\link{MaskImages}()}
}
\concept{image transformations}
