---
title: "Neighborhood Enrichment Analysis"
format: html
editor: visual
editor_options: 
  chunk_output_type: inline
---

## Introduction

Creating a new analysis to perform a neighborhood enrichment test between each unique spot cluster label pair, thus checking whether spots of label "X" and spots of label "Y" appear more often or not next to each other as compared to randomly assigned spot labels.

```{r warning=FALSE, message=FALSE}
library(tibble)
library(ggplot2)
library(patchwork)
library(scico)
library(ggsci)
library(tidyr)
library(dplyr)

library(STUtility2)
```

```{r}
theme_dark_custom <- theme(panel.background = element_rect(fill="grey15", colour = NA), 
                           plot.background = element_rect(fill="grey15", colour = NA), 
                           text = element_text(color="white"))
```

## Functions

### randomize_label_ids

Helper function to randomize the spot id labels within each sample separately. Option to set a fixed random seed for each permutation if you want reproducible results.

```{r func_randomize_label_ids}
#' Randomise Label IDs within each sample
#'
#' @param object Seurat object containing label and sample identities for each spot in the metadata.
#' @param column_name Column name in metadata corresponding to label ID of the spots. Default "seurat_clusters".
#' @param random_seed
#' 
#' @return New Seurat object with shuffled label identities per sample
#' 
#' @noRd
randomize_label_ids <- function (
    object,
    column_name,
    random_seed = NA
) {
  if(!is.na(random_seed)){
    set.seed(random_seed)
  }

  #' Fetch original labels
  new_md_rand <- setNames(GetStaffli(object)@meta_data[,c("barcode", "sampleID")] |> 
                            bind_cols(object[[]] |> select(all_of(column_name))),
                          nm = c("barcode", "sampleID", "original_labels"))
  
  #' Shuffle label ids for each sample
  new_md_rand <- new_md_rand |> 
    group_by(sampleID) |> 
    mutate(perm_labels = original_labels[sample(dplyr::row_number())])
  
  #' Add shuffled labels to se object metadata
  object$perm_labels <- ""
  object <- AddMetaData(object, new_md_rand$perm_labels, col.name = "perm_labels")

  return(object)
}
```

### RunNeighborhoodEnrichmentTest

```{r func_RunNeighborhoodEnrichmentTest}
#' Neighborhood Enrichment Analysis
#' 
#' @description
#' Performs Neighborhood Enrichment Analysis between spot labels, describing whether
#' spots of two categories lie next to each other spatially more often than expected
#' by chance.
#'
#' @details
#' This analysis calculates the enrichment score, z-score, based on how often spots 
#' of different categorical labels (specified with \code{column_name}) lies 
#' adjacent to each other. The observed number of edges between the labels is 
#' then compared with the results from a set number of permutations (chosen 
#' with \code{n_permutations}), allowing the calculation of a z-score.
#' The z-score will indicate if a label pair is overrepresented or underrepresented
#' as compared to what would be expected to see by chance.
#' The output of this function is a tibble table that for each label pair contains
#' information about the observed number of edges (`edges`), the mean of the permuted
#' results (`perm_mean`), the standard deviation of the permuted results (`perm_sd`),
#' and the z-score (`z_score`).
#'
#' @param object A Seurat object
#' @param column_name Column name in metadata corresponding to label ID of the spots.
#' @param column_labels Optional. Provide vector of label IDs to subset your analysis by. 
#' Spots of all other labels will be excluded. Must be more than one. Default is all (NA).
#' @param n_permutations Integer specifying number of iterations the labels should be randomized 
#' [default: 100]. Recommended to increase the number of permutations to >=100 for more robust
#' results. A lower number of permutations will result in high standard deviations and thus more
#' unreliable z-scores.
#' @param fixed_random_seed A logical spefiying if a fixed random seed for the permutations
#' should be used. [default: FALSE]
#' @param minK Minimum nearest neighbors when generating spatial network using the \code{\link{GetSpatialNetwork}} function [default: 0]. Spots with fewer neighbors will be 
#' discarded. Useful if you want to remove spots with few or no neighbors.
#' @param n_cores Number of cores. [default: parallel::detectCores()-1]
#' @param verbose Print messages [default: TRUE]
#'
#'
#' @import dplyr
#' @import cli
#' @importFrom tibble tibble
#' @importFrom rlang abort
#' 
#' @rdname neighborhood-enrichment
#' @family spatial-methods
#'
#' @author Lovisa Franz√©n
#' 
#'
#' @examples
#' \dontrun{
#' library(STUtility2)
#' 
#' # Read data
#' se <- readRDS(system.file("extdata/mousebrain", 
#'                           "se_mbrain", 
#'                           package = "STUtility2"))
#'                           
#' # Generate clusters
#' se <- se |>
#'   NormalizeData() |>
#'   ScaleData() |>
#'   FindVariableFeatures() |>
#'   RunPCA() |>
#'   FindNeighbors(reduction = "pca", dims = 1:30) |>
#'   FindClusters()
#' }
#' 
#' # Run Neigborhood Enrichment Analysis
#' nea_results <- RunNeighborhoodEnrichmentTest(object = se, 
#'                                              column_name = "seurat_clusters",
#'                                              n_permutations = 1000)
#' 
#' 
#' @export
RunNeighborhoodEnrichmentTest <- function(
    object,
    column_name,
    column_labels = NA,
    n_permutations = 100,
    fixed_random_seed = FALSE,
#    minK = 0,  # Skip this??
    n_cores = parallel::detectCores()-1,
    verbose = TRUE
    ){
  
  # checks - import from checks.R and spatial_utils.R
  # .check_seurat_object(object)
  # .validate_column_name(object = object, column_name = column_name)
  
  # checks
  if (n_permutations != round(n_permutations)) rlang::abort("Invalid input for 'n_permutations', expected a numeric integer")
  if (n_permutations <= 1) rlang::abort("Invalid input for 'n_permutations', needs to be more than 1")
  if (!is.logical(fixed_random_seed)) rlang::abort("Invalid input for 'fixed_random_seed', expected a logical")
  
  # check column labels
  if (!is.na(column_labels[1])) {
    if (length(unique(column_labels))<=1) rlang::abort("Provided unique 'column_labels' needs to be more than 1")
    if (sum(column_labels %in% unique(object[[column_name]][,1])) < length(column_labels)) rlang::abort("Some of the provided 'column_labels' can not be found among the 'column_name' labels. Please provide valid 'column_labels'")
  }
  
  # Start analysis
  if (verbose) cli::cli_h2("Running Neighborhood Enrichment Analysis")
  if (verbose) cli::cli_alert_info("Generating neighborhood adjacency data from observed labels in column '{column_name}'")
  
  if (!is.na(column_labels[1])) {
    if (sum(duplicated(column_labels))>0) {
      cli::cli_alert_warning("Provided 'column_labels' contains duplicated values. Continuing analysis with abundant labels removed.")
      column_labels <- unique(column_labels)
    }
    if (verbose) cli::cli_alert_info("Analysis limited to study {length(column_labels)} unique labels")
  }
  
  # Filter object if custom column_labels are provided
  if (!is.na(column_labels[1])) {
    spots_keep <- rownames(object[[]])[object[[]][,column_name] %in% column_labels]
    object <- SubsetSTData(object, spots = spots_keep)
  }

  # Generate spatnet
  spatnet <- do.call(bind_rows, GetSpatialNetwork(object))  # , minK = minK, maxDist = Inf
  spatnet$label_from <- object[[]][spatnet$from, column_name, drop = TRUE]
  spatnet$label_to <- object[[]][spatnet$to, column_name, drop = TRUE]
  
  
  # Create template with available label-label options
  if (is.na(column_labels[1])) {
    unique_labels <- paste0("Label_", levels(object[[column_name]][,1]))
  } else {
    unique_labels <- paste0("Label_", column_labels)
  }
  unique_labels <- factor(unique_labels, levels = unique_labels)
  label_label_template <- setNames(crossing(unique_labels, unique_labels), 
                                   nm = c("label_1", "label_2")) |> 
    mutate(label_label = paste0(label_1, "-", label_2))
  

  # Generate weighted edge lists from region neighbors of observed labels
  edge_table <- spatnet |> 
    add_column(
      label_1 = paste0("Label_", as.character(object[[]][spatnet$from, column_name, drop = TRUE])),
      label_2 = paste0("Label_", as.character(object[[]][spatnet$to, column_name, drop = TRUE]))
      ) |> 
    mutate(label_label = paste0(label_1, "-", label_2))
  
  # Count number of edges per unique label-label pair
  edge_table_stats <- edge_table |> 
    group_by(label_label) |> 
    summarize(.groups = "keep", edges = n()) |> 
    ungroup()
  
  edge_table_stats <- merge(x = label_label_template, 
                            y = edge_table_stats, 
                            by = "label_label", 
                            all.x = T, 
                            sort = FALSE) |> 
    mutate_at("edges", ~replace_na(.,0)) |> 
    as_tibble()
  
  if (verbose) message("")
  if (verbose) cli::cli_alert_success("Observed label adjacency calculations complete")
  
  
  # Generate weighted edge lists from region neighbors of randomized labels
  if (verbose) cli::cli_alert_info("Generating neighborhood adjacency data from randomized labels")
  if (n_permutations < 25) {
      cli::cli_alert_warning("The number of selected permutations is low (<25). Consider increasing 'n_permutations' for more robust results")
  }
  
  if (verbose & fixed_random_seed) cli::cli_alert_info("Using a fixed unique random seed for each iteration")
  
  perm_edge_list <- parallel::mclapply(1:n_permutations, function(i){
    # Permute column_labels
    if ("perm_labels" %in% colnames(object@meta.data)) {
      object$perm_labels <- NULL
    }
  
    if(fixed_random_seed){
      object <- randomize_label_ids(object = object, 
                                    column_name = column_name, 
                                    random_seed = i)
      } else {
        object <- randomize_label_ids(object = object, 
                                      column_name = column_name, 
                                      random_seed = NA)
      }
      
    # Generate weighted edge lists from region neighbors of randomized labels
    perm_edge_table <- spatnet |> 
      add_column(
        label_1 = paste0("Label_", as.character(object[[]][spatnet$from, "perm_labels", drop = TRUE])),
        label_2 = paste0("Label_", as.character(object[[]][spatnet$to, "perm_labels", drop = TRUE]))
        ) |> 
      mutate(label_label = paste0(label_1, "-", label_2))
    
    # Count number of edges per unique label-label pair
    perm_edge_table_stats <- perm_edge_table |> 
      group_by(label_label) |> 
      summarize(.groups = "keep", edges = n()) |> 
      ungroup()
    
    perm_edge_table_stats <- merge(
                              x = label_label_template, 
                              y = perm_edge_table_stats, 
                              by = "label_label", 
                              all.x = T,
                              sort = FALSE) |> 
      mutate_at("edges", ~replace_na(.,0)) |> 
      as_tibble()
    }, 
    mc.cores = n_cores, 
    mc.preschedule = T
  )
  if (verbose) cli::cli_alert_success("Randomized label adjacency calculations complete from {n_permutations} iterations")

  # Compute mean and sd from permutations
  perm_edge_df <- do.call(bind_rows, perm_edge_list)
  perm_res <- perm_edge_df |> 
    group_by(label_label) |> 
    summarise(.groups = "keep", 
              perm_mean = mean(edges), 
              perm_sd = sd(edges)) |> 
    ungroup()
  
  # Prepare results output and compute z-scores
  res_out <- full_join(x = edge_table_stats, y = perm_res, by = "label_label") |> 
    filter(label_1 != label_2)
  res_out[res_out$perm_sd == 0, "perm_sd"] <- 0.0001  # add pseudocount if sd is 0
  res_out$z_score <- round((res_out$edges - res_out$perm_mean) / (res_out$perm_sd),
                           digits = 3)
  
  if (verbose) cli::cli_alert_success("Scores calculated for each label pair and returned as output tibble")
  
  return(res_out)
}
```

Function components - skip

```{r}
# object <- se
# column_name <- "seurat_clusters"
# # minK <- 0
# column_labels <- NA
# n_permutations <- 50
# n_cores <- parallel::detectCores()-1
# 
# # Generate spatnet
# spatnet <- do.call(bind_rows, GetSpatialNetwork(object))  # , minK = minK, maxDist = Inf
# spatnet$label_from <- object[[]][spatnet$from, column_name, drop = TRUE]
# 
# 
# # Filter spatnet if custom column_labels are provided
# if (!is.na(column_labels[1])) {
#   spatnet <- subset(spatnet, label_from %in% column_labels)
# }
# 
# # Create template with available label-label options
# if (!is.na(column_labels[1])) {
#   unique_labels <- paste0("Label_", levels(object[[column_name]][,1]))
# } else {
#   unique_labels <- paste0("Label_", column_labels)
# }
# unique_labels <- factor(unique_labels, levels = unique_labels)
# label_label_template <- setNames(crossing(unique_labels, unique_labels), 
#                                  nm = c("label_1", "label_2")) |> 
#   mutate(label_label = paste0(label_1, "-", label_2))
# 
# 
# 
# 
# # Generate weighted edge lists from region neighbors of observed labels
# edge_table <- spatnet |> 
#   add_column(
#     label_1 = paste0("Label_", as.character(object[[]][spatnet$from, column_name, drop = TRUE])),
#     label_2 = paste0("Label_", as.character(object[[]][spatnet$to, column_name, drop = TRUE]))
#     ) |> 
#   mutate(label_label = paste0(label_1, "-", label_2))
# 
# # Count number of edges per unique label-label pair
# edge_table_stats <- edge_table |> 
#   group_by(label_label) |> 
#   summarize(.groups = "keep", edges = n()) |> 
#   ungroup()
# 
# edge_table_stats <- merge(x = label_label_template, 
#                           y = edge_table_stats, 
#                           by = "label_label", 
#                           all.x = T, 
#                           sort = FALSE) |> 
#   mutate_at("edges", ~replace_na(.,0)) |> 
#   as_tibble()
# 
# 
# perm_edge_list <- parallel::mclapply(1:n_permutations, function(i){
#   # Permute column_labels
#   if ("perm_labels" %in% colnames(object@meta.data)) {
#     object$perm_labels <- NULL
#   }
#   object <- randomize_label_ids(object = object, 
#                                 column_name = column_name, 
#                                 random_seed = NA)
#   
#   # Generate weighted edge lists from region neighbors of randomized labels
#   perm_edge_table <- spatnet |> 
#     add_column(
#       label_1 = paste0("Label_", as.character(object[[]][spatnet$from, "perm_labels", drop = TRUE])),
#       label_2 = paste0("Label_", as.character(object[[]][spatnet$to, "perm_labels", drop = TRUE]))
#       ) |> 
#     mutate(label_label = paste0(label_1, "-", label_2))
#   
#   # Count number of edges per unique label-label pair
#   perm_edge_table_stats <- perm_edge_table |> 
#     group_by(label_label) |> 
#     summarize(.groups = "keep", edges = n()) |> 
#     ungroup()
#   
#   perm_edge_table_stats <- merge(x = label_label_template, 
#                             y = perm_edge_table_stats, 
#                             by = "label_label", 
#                             all.x = T,
#                             sort = FALSE) |> 
#     mutate_at("edges", ~replace_na(.,0)) |> 
#     as_tibble()
#   
#   }, 
#   mc.cores = n_cores, 
#   mc.preschedule = T
#   )
# 
# perm_edge_df <- do.call(bind_rows, perm_edge_list)
# 
# perm_res <- perm_edge_df |> 
#   group_by(label_label) |> 
#   summarise(.groups = "keep", 
#             perm_mean = mean(edges), 
#             perm_sd = sd(edges)) |> 
#   ungroup()
# 
# 
# # Prepare results output and compute z-scores
# res_out <- full_join(x = edge_table_stats, y = perm_res, by = "label_label") |> 
#   filter(label_1 != label_2)
# 
# res_out$z_score <- round((res_out$edges - res_out$perm_mean) / (res_out$perm_sd + 0.0001),
#                          digits = 3)
# 
# res_out
```

plot spatnet - skip

```{r}
# spatnet_plot <- spatnet |> 
#   add_column(
#     label_1 = paste0("Label_", as.character(object[[]][spatnet$from, column_name, drop = TRUE])),
#     label_2 = paste0("Label_", as.character(object[[]][spatnet$to, column_name, drop = TRUE]))
#     )
# 
# 
# spatnet_plot2 <- spatnet |> 
#   add_column(
#     label_1 = paste0("Label_", as.character(object[[]][spatnet$from, "perm_labels", drop = TRUE])),
#     label_2 = paste0("Label_", as.character(object[[]][spatnet$to, "perm_labels", drop = TRUE]))
#     )
# 
# 
# ggplot() +
#   geom_segment(data = spatnet_plot2, 
#                aes(x = x_start, xend = x_end, y = y_start, yend = y_end)) +
#   geom_point(data = dplyr::filter(spatnet_plot2,
#                                   label_1 %in% "Label_1" & label_2 %in% "Label_2"),
#              mapping = aes(x = x_start, y = y_start),
#              color="blue") +
#   geom_point(data = dplyr::filter(spatnet_plot2,
#                                   label_1 %in% "Label_2" & label_2 %in% "Label_1"),
#              mapping = aes(x = x_start, y = y_start),
#              color="red") +
#   scale_y_reverse() +
#   coord_fixed() +
#   theme_bw()
```

## Example Data 1: Mouse brain

### Load and prepare data

```{r}
se <- readRDS(system.file("extdata/mousebrain", 
                           "se_mbrain", 
                           package = "STUtility2"))

se@tools$Staffli@imgs <- system.file("extdata/mousebrain", 
                                      "spatial/tissue_hires_image.png",
                                      package = "STUtility2")
```

```{r message=FALSE, warning=FALSE}
se <- se |>
  NormalizeData() |>
  ScaleData() |>
  FindVariableFeatures() |>
  RunPCA() |>
  FindNeighbors(reduction = "pca", dims = 1:30) |>
  FindClusters()
```

```{r}
# cols_cluster <- setNames(scico::scico(length(unique(se$seurat_clusters)), palette = "roma"),
#                          nm = sort(unique(se$seurat_clusters)))

cols_cluster <- setNames(ggsci::pal_d3("category20")(length(unique(se$seurat_clusters))),
                         nm = sort(unique(se$seurat_clusters)))

MapLabelsSummary(se, 
                 column_name = "seurat_clusters",
                 colors = cols_cluster) & 
  theme_dark_custom
```

```{r}
MapLabels(se, 
          column_name = "seurat_clusters",
          split_labels = T, 
          ncol = 4, 
          pt_size = 0.5,
          colors = cols_cluster) & 
  theme(legend.position = "none")
```

### NeighborhoodEnrichmentAnalysis

#### Main analysis

```{r}
nea_results <- RunNeighborhoodEnrichmentTest(object = se, column_name = "seurat_clusters")

head(nea_results)
```

Let's have a look at the output.

```{r}
dim(nea_results)
unique(nea_results$label_2)
```

```{r}
nea_results |> 
  arrange(desc(abs(z_score)))
```

**Plot results as heatmap**

```{r fig.width=6, fig.height=6}
hm_plot_data <- nea_results

hm_plot_data$label_1 <- factor(hm_plot_data$label_1, 
                               levels = paste0("Label_", sort(unique(se$seurat_clusters))))
hm_plot_data$label_2 <- factor(hm_plot_data$label_2, 
                               levels = paste0("Label_", sort(unique(se$seurat_clusters))))

ggplot(hm_plot_data, aes(label_1, label_2, fill= z_score)) + 
  geom_tile(color = "white",
            lwd = 1.5,
            linetype = 1) +
  scale_fill_gradient2(low = "#0474BA",
                       mid = "grey90",
                       high = "#F17720") +
  labs(x="", y="", title="Neighborhood enrichment", fill="Z-score") +
  theme_bw() +
  coord_fixed() +
  theme(panel.grid.major = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(hjust=0.5, size=12, face = "bold"),
        axis.text = element_text(size=10),
        legend.title = element_text(size=10), 
        legend.text = element_text(size=10))
```

#### 

Plot top negative and positive z-scores

```{r fig.width=10, fig.height=6}
# Select top enriched pairs
top_n_plot <- 10
plot_data <- nea_results |> 
  mutate(across(where(is.factor), as.character)) |> 
  group_by(grp = paste0(pmin(label_1, label_2), "-", pmax(label_1, label_2))) |> 
  slice(1)  |> 
  ungroup()  |> 
  select(-grp)

plot_data <- rbind(
  plot_data |> arrange(z_score) |> head(top_n_plot) |> filter(z_score < 0),
  plot_data |> arrange(desc(z_score)) |> head(top_n_plot) |> filter(z_score > 0)
  )

# Add info about enrichment direction
plot_data$direction <- ifelse(plot_data$z_score>0, "overrepresented", "underrepresented")
colors_direction_fill <- setNames(c("#F17720", "#0474BA"), nm = c("overrepresented", "underrepresented"))

# Make plot
ggplot(plot_data, aes(x=reorder(label_label, z_score), y=z_score, fill = direction)) +
  geom_col(width = 0.6) +
  labs(x="", y="Z-score", title="Top enriched label pairs", fill="Enrichment") +
  scale_fill_manual(values = colors_direction_fill) +
  geom_hline(yintercept = 0, color="black", size=0.5) +
  coord_flip() +
  theme_linedraw() +
  theme(plot.title = element_text(hjust=0.5, size=12, face = "bold"),
        # axis.text.x = element_text(angle = 45, hjust = 1),
        axis.text = element_text(size=10),
        panel.grid = element_blank(), 
        legend.position = "top", 
        legend.title = element_text(size=10), 
        legend.text = element_text(size=10))
```

Have a look at the spatial location of the most enriched cluster pairs.

```{r}
p_up <- (
  MapLabels(SubsetSTData(se, seurat_clusters %in% c(3,9)), 
          column_name = "seurat_clusters",
          colors = cols_cluster) + labs(title="clusters 3+9") | 
  MapLabels(SubsetSTData(se, seurat_clusters %in% c(8,11)), 
          column_name = "seurat_clusters",
          colors = cols_cluster) + labs(title="clusters 8+11") |
  MapLabels(SubsetSTData(se, seurat_clusters %in% c(8,10)), 
          column_name = "seurat_clusters",
          colors = cols_cluster) + labs(title="clusters 8+10"))

p_down <- (
  MapLabels(SubsetSTData(se, seurat_clusters %in% c(0,1)), 
          column_name = "seurat_clusters",
          colors = cols_cluster) + labs(title="clusters 0+1") | 
  MapLabels(SubsetSTData(se, seurat_clusters %in% c(0,3)), 
          column_name = "seurat_clusters",
          colors = cols_cluster) + labs(title="clusters 0+3") | 
  MapLabels(SubsetSTData(se, seurat_clusters %in% c(0,2)), 
          column_name = "seurat_clusters",
          colors = cols_cluster) + labs(title="clusters 0+2"))

p_up/p_down & theme(legend.position = "none")
```

#### Run analysis with label subset

```{r}
nea_results2 <- RunNeighborhoodEnrichmentTest(object = se, 
                                         column_name = "seurat_clusters", 
                                         # column_labels = c("0","3","8","9"),
                                         column_labels = c(1:3,5:10),
                                         n_permutations = 50)
head(nea_results2)
```

```{r}
nea_results2 |> 
  arrange(desc((z_score)))
```

```{r}
hm_plot_data <- nea_results2
hm_plot_data$label_1 <- factor(hm_plot_data$label_1, 
                               levels = paste0("Label_", sort(unique(se$seurat_clusters))))
hm_plot_data$label_2 <- factor(hm_plot_data$label_2, 
                               levels = paste0("Label_", sort(unique(se$seurat_clusters))))

ggplot(hm_plot_data, aes(label_1, label_2, fill= z_score)) + 
  geom_tile(color = "white",
            lwd = 1.5,
            linetype = 1) +
  scale_fill_gradient2(low = "#0474BA",
                       mid = "grey90",
                       high = "#F17720") +
  labs(x="", y="") +
  theme_bw() +
  coord_fixed() +
  theme(panel.grid.major = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1))
```

#### Function run time

Running time

```{r}
perm_test <- c(10, 25, 50, 75, 100, 150, seq(from=200, to=1000, by=100))
f_time_perms <- lapply(perm_test, function(n_perm){
  message(n_perm)
  f_time <- system.time(result <- RunNeighborhoodEnrichmentTest(object = se, 
                                                          column_name = "seurat_clusters", 
                                                          n_permutations = n_perm, 
                                                          verbose = F))

  f_time[3]
})

f_time_perms_df <- setNames(do.call(bind_rows, f_time_perms),
                            nm = "time")
f_time_perms_df$n_perm <- perm_test
```

```{r}
f_time_perms_df
```

```{r}
ggplot(f_time_perms_df, aes(x=n_perm, y=time)) +
  geom_line() +
  geom_point() +
  labs(x="n_permutations", "time (s)", title="Analysis run time") +
  theme_linedraw()
```

#### Testing of function arguments

**Column name**

Don't work:

```{r}
res <- RunNeighborhoodEnrichmentTest(object = se, column_name = "awsd")
```

Works:

```{r}
se$clusters <- se$seurat_clusters
res <- RunNeighborhoodEnrichmentTest(object = se, column_name = "clusters")
```

**Permutations**

Don't work:

```{r}
res <- RunNeighborhoodEnrichmentTest(object = se, column_name = "seurat_clusters", n_permutations = 1)
```

Works:

```{r}
res <- RunNeighborhoodEnrichmentTest(object = se, column_name = "seurat_clusters", n_permutations = 2)
```

**Random seed**

```{r}
# fixed_random_seed = FALSE
for(i in 1:5){
  res <- RunNeighborhoodEnrichmentTest(object = se, column_name = "seurat_clusters", 
                                   n_permutations = 25,
                                   fixed_random_seed = F, 
                                   verbose = F)
  print(head(res))
}
```

```{r}
# fixed_random_seed = TRUE
for(i in 1:5){
  res <- RunNeighborhoodEnrichmentTest(object = se, column_name = "seurat_clusters", 
                                   n_permutations = 25,
                                   fixed_random_seed = T, 
                                   verbose = F)
  print(head(res))
}
```

**Column labels**

Don't work:

```{r}
res <- RunNeighborhoodEnrichmentTest(object = se, column_name = "seurat_clusters", 
                                 column_labels = 1)
```

Don't work:

```{r}
res <- RunNeighborhoodEnrichmentTest(object = se, column_name = "seurat_clusters", 
                                 column_labels = c(1, "abc"))
```

Works:

```{r}
res <- RunNeighborhoodEnrichmentTest(object = se, column_name = "seurat_clusters", 
                                 column_labels = c(1, 4, "10"))
```

**n_cores**

```{r}
parallel::detectCores()

# 1 core
system.time(RunNeighborhoodEnrichmentTest(object = se, column_name = "seurat_clusters", 
                                      n_permutations = 25, verbose = F,
                                      n_cores = 1)
            )

# 4 cores
system.time(RunNeighborhoodEnrichmentTest(object = se, column_name = "seurat_clusters", 
                                      n_permutations = 25, verbose = F,
                                      n_cores = 4)
            )
```

## Example Data 2: BC data

Test analysis with data from two samples.

### Load and prepare data

```{r}
samples <- Sys.glob(file.path(here::here(), "BC_data/*/filtered_feature_bc_matrix.h5"))[1:2]
imgs <- Sys.glob(file.path(here::here(), "BC_data/*/spatial/tissue_hires_image.png"))[1:2]
spotfiles <- Sys.glob(file.path(here::here(), "BC_data/*/spatial/tissue_positions_list.csv"))[1:2]
json <- Sys.glob(file.path(here::here(), "BC_data/*/spatial/scalefactors_json.json"))[1:2]

# Create a tibble/data.frame with file paths
infoTable <- tibble(samples, imgs, spotfiles, 
                    json, sample_id = c("S1", "S2"))

# Create Seurat object
bc_se <- ReadVisiumData(infoTable = infoTable)
```

```{r message=FALSE, warning=FALSE}
bc_se <- bc_se |>
  NormalizeData() |>
  ScaleData() |>
  FindVariableFeatures() |>
  RunPCA() |>
  FindNeighbors(reduction = "pca", dims = 1:30) |>
  FindClusters()
```

```{r fig.width=10, fig.height=4}
cols_cluster <- setNames(ggsci::pal_d3("category20")(length(unique(bc_se$seurat_clusters))),
                         nm = sort(unique(bc_se$seurat_clusters)))

MapLabelsSummary(bc_se, 
                 column_name = "seurat_clusters",
                 colors = cols_cluster) & 
  theme_dark_custom
```

### NeighborhoodEnrichmentAnalysis

#### Run analysis

```{r}
nea_results <- RunNeighborhoodEnrichmentTest(object = bc_se, column_name = "seurat_clusters")
```

```{r}
nea_results |> 
  arrange(desc(abs(z_score)))
```

#### Plot results

**Heatmap**

```{r fig.width=6, fig.height=6}
cluster_labels <- paste0("Label_", sort(unique(bc_se$seurat_clusters)))
hm_plot_data <- nea_results

hm_plot_data$label_1 <- factor(hm_plot_data$label_1, levels = cluster_labels)
hm_plot_data$label_2 <- factor(hm_plot_data$label_2, levels = cluster_labels)

ggplot(hm_plot_data, aes(label_1, label_2, fill= z_score)) + 
  geom_tile(color = "white",
            lwd = 1.5,
            linetype = 1) +
  scale_fill_gradient2(low = "#0474BA",
                       mid = "grey90",
                       high = "#F17720") +
  labs(x="", y="", title="Neighborhood enrichment", fill="Z-score") +
  theme_bw() +
  coord_fixed() +
  theme(panel.grid.major = element_blank(),
        axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(hjust=0.5, size=12, face = "bold"),
        axis.text = element_text(size=10),
        legend.title = element_text(size=10), 
        legend.text = element_text(size=10))
```

**Bar chart of top enriched pairs**

```{r fig.width=10, fig.height=6}
top_n_plot <- 10
plot_data <- nea_results |> 
  mutate(across(where(is.factor), as.character)) |> 
  group_by(grp = paste0(pmin(label_1, label_2), "-", pmax(label_1, label_2))) |> 
  slice(1)  |> 
  ungroup()  |> 
  select(-grp)

plot_data <- rbind(
  plot_data |> arrange(z_score) |> head(top_n_plot) |> filter(z_score < 0),
  plot_data |> arrange(desc(z_score)) |> head(top_n_plot) |> filter(z_score > 0)
  )

plot_data$direction <- ifelse(plot_data$z_score>0, "overrepresented", "underrepresented")
colors_direction_fill <- setNames(c("#F17720", "#0474BA"), nm = c("overrepresented", "underrepresented"))

ggplot(plot_data, aes(x=reorder(label_label, z_score), y=z_score, fill = direction)) +
  geom_col(width = 0.6) +
  labs(x="", y="Z-score", title="Top enriched label pairs", fill="Enrichment") +
  scale_fill_manual(values = colors_direction_fill) +
  geom_hline(yintercept = 0, color="black", size=0.5) +
  coord_flip() +
  theme_linedraw() +
  theme(plot.title = element_text(hjust=0.5, size=12, face = "bold"),
        # axis.text.x = element_text(angle = 45, hjust = 1),
        axis.text = element_text(size=10),
        panel.grid = element_blank(), 
        legend.position = "top", 
        legend.title = element_text(size=10), 
        legend.text = element_text(size=10))
```

**Spatial plot**

Look at most up and down enriched cluster pairs.

```{r fig.width=10, fig.height=8}
p_up <- (
  MapLabels(SubsetSTData(bc_se, seurat_clusters %in% c(10,12)), 
          column_name = "seurat_clusters", pt_size = 1.25,
          colors = cols_cluster, override_plot_dims = F) / 
  MapLabels(SubsetSTData(bc_se, seurat_clusters %in% c(1,15)), 
          column_name = "seurat_clusters", pt_size = 1.25,
          colors = cols_cluster, override_plot_dims = F) /
  MapLabels(SubsetSTData(bc_se, seurat_clusters %in% c(14,16)), 
        column_name = "seurat_clusters", pt_size = 1.25,
        colors = cols_cluster, override_plot_dims = F)
  ) + 
  plot_layout(guides = "collect") &
  theme(legend.position = "right")

p_down <- (
  MapLabels(SubsetSTData(bc_se, seurat_clusters %in% c(0,1)), 
            column_name = "seurat_clusters", pt_size = 1.25,
            colors = cols_cluster, override_plot_dims = F) / 
  MapLabels(SubsetSTData(bc_se, seurat_clusters %in% c(0,3)),
            column_name = "seurat_clusters", pt_size = 1.25,
            colors = cols_cluster, override_plot_dims = F)
  ) + 
  plot_layout(guides = "collect") &
  theme(legend.position = "right")

p_up
p_down
```

\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-- SKIP \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

## Random and backup stuff

### ModifiedRegionNeighbors

```{r func_ModifiedRegionNeighbors, eval=F}
#' Create table with spot region neighbour information
#' 
#' A modified version of the \code{\link{RegionNeighbors}} function.
#'
#' @param object A Seurat object
#' @param spatial_network Optional. Provide pregenerated list of tibbles 
#' containing spatial networks generated with \code{\link{GetSpatialNetwork}}
#' @param column_name Column name in metadata corresponding to label ID of 
#' the spots.
#' @param column_labels Vector of label IDs to include in your analysis if 
#' onla a subset of labels should be considered. Must be more than one. 
#' Default is all (NA).
#' 
#' @import dplyr
#' 
#' @return data frame with info about spot cluster neighbors
#' 
ModifiedRegionNeighbors <- function(
    object,
    spatial_network = NULL,
    column_name,
    column_labels = NA,
    column_key = "nb_"
    )
  {
  # Generate spatial network if neededs
  if (is.null(spatial_network)) {
    spatnet <- GetSpatialNetwork(object)
  }

  # Check and format column_labels
  if (length(column_labels)==1 & is.na(column_labels[1])) {
    column_labels <- object@meta.data[, column_name] |> unique()
  }
  column_labels <- column_labels |>
      sort() |>
      as.character()

  # Code copied from RegionNeighbors function
  spots_list <- lapply(column_labels, function(lbl) {
    spots <- GetStaffli(object)@meta_data |>
      bind_cols(object[[]] |> select(all_of(column_name))) |>
      mutate_if(is.factor, as.character) |>
      filter(!! sym(column_name) == lbl) |>
      pull(barcode)
    }) |>
    setNames(column_labels)

  # Modified code from RegionNeighbors function
  nbs <- setNames(lapply(names(spots_list), function(nm) {
    spots <- spots_list[[nm]]
    to_spots <- RegionNeighbors(spatnet,
                                spots,
                                mode = "outer",
                                verbose = FALSE)
    to_spots <- tibble(to_spots, nm) |>
      setNames(nm = c("barcode", column_name)) |>
      distinct()
    return(to_spots)
  }), nm = column_labels)

  # Code copied from RegionNeighbors function
  # Reformat output data
  nbs_rearranged <- do.call(bind_cols, lapply(column_labels, function(lbl) {
    left_join(x = GetStaffli(object)@meta_data |>
                select(barcode) |>
                bind_cols(object[[]] |> select(all_of(column_name))),
              y = nbs[[lbl]],
              by = "barcode") |>
      select(-barcode) |>
      setNames(nm = c("var1", "var2")) |>
      mutate_if(is.factor, as.character) |>
      mutate(var2 = case_when((!is.na(var2)) & (var1 != var2) ~ paste0(column_key, lbl),
                              TRUE ~ var2)) |>
      select(var2) |>
      setNames(nm = paste0(column_key, lbl))
  }))

  # Prepare for export
  nb_data <- object@meta.data |>
    select(contains(column_name), -contains(colnames(nbs_rearranged))) |>
    bind_cols(nbs_rearranged)

  return(nb_data)
}

```

### CreateAdjMatrix

```{r func_CreateAdjMatrix, eval=F}
#' Create Adjacency Matrix from an arranged neighborhood data frame
#'
#' @param nb_df Data frame with info about spot cluster neighbors, corresponding 
#' to the output generated by ¬¥ModifiedRegionNeighbors()¬¥ or 
#' ¬¥RegionNeighbors(..., mode = "outer", column_key = "nb_")¬¥. 
#' Rows should correspond to spot ID and columns should include the column_name 
#' as well as columns starting with "nb_".
#' @param column_name Column name in nb_df corresponding to label ID of the spots.
#' @param column_labels Vector of label IDs to include in your analysis. Must be 
#' more than one. Default is all (NA).
#' @param return_as_tibble A logical whether to return the adjacency matrix as a
#' tibble table with weighted edge lists instead of a matrix. [default: FALSE]
#' 
#' @return Adjacency matrix with number of neighbours present between each feature pair
#' 
#' @export
CreateAdjMatrix <- function(
    nb_df,
    column_name,
    column_labels = NA,
    return_as_tibble = FALSE
){

  #' Check and format column_labels
  if (length(column_labels)<=1 & is.na(column_labels[1])) {
    column_labels <- nb_df[,column_name] |> unique()
  }
  column_labels <- column_labels |>
      sort() |>
      as.character()

  #' Generate Adjacency Matrix
  nb_adjmat <- matrix(0L, nrow = length(column_labels), ncol = length(column_labels))
  for (i in seq_along(column_labels)) {
    c <- column_labels[i]
    c_nbs_df <- nb_df[nb_df[,column_name]==c, ]
    for (j in seq_along(column_labels)) {
      nbs <- paste0("nb_", column_labels[j])
      if (j==i) {
        n_nbs <- sum(!is.na(c_nbs_df[, nbs]==c))
      } else {
        n_nbs <- sum(!is.na(c_nbs_df[, nbs]==nbs))
      }
      nb_adjmat[i,j] <- n_nbs
      if (nb_adjmat[j,i] > 0) {
        nb_adjmat[i,j] <- nb_adjmat[j,i] <- max(c(nb_adjmat[i,j], nb_adjmat[j,i]))
      }
    }
    nb_adjmat[i,i] <- sum(nb_adjmat[i,][-i])
  }

  #' Set row/column names
  rownames(nb_adjmat) <- colnames(nb_adjmat) <- paste0("Label_", column_labels)

  # Return adjacency matrix or edge list
  if(!return_as_tibble){
    return(nb_adjmat)
  } else if (return_as_tibble) {
    return(convert_adj_mat_to_long(nb_adjmat))
  }
}
```

### convert_adj_mat_to_long

```{r func_convert_adj_mat_to_long, eval=F}
#' Convert adjacency matrix to an edge list with long format and remove redundancy
#'
#' @param adj_mat Adjacency matrix as created by 
#'
#' @import tidyr
#' @import dplyr
#'
#' @return A tibble 
#'
#' @noRd
convert_adj_mat_to_long <- function (adj_mat) {
  adj_mat_long <- adj_mat|>
    as.data.frame()
  adj_mat_long$label_1 <- rownames(adj_mat_long)
  adj_mat_long <- adj_mat_long |>
    pivot_longer(cols = colnames(adj_mat),
                 names_to = "label_2",
                 values_to = "edges")
  adj_mat_long_filt <- subset(adj_mat_long,
                              label_1 != label_2 &
                                !duplicated(cbind(pmin(label_1, label_2), pmax(label_2, label_1))))
  adj_mat_long_filt$label_label <- paste0(adj_mat_long_filt$label_1, "-", adj_mat_long_filt$label_2)
  adj_mat_long_filt <- adj_mat_long_filt |> relocate(label_1, label_2, label_label, edges)
  return(adj_mat_long_filt)
}
```

### GeneratePermutedResults

```{r func_GeneratePermutedResults, eval=F}
#' GeneratePermutedResults
#'
#' @param spatnet A list of tibbles containing spatial networks generated with
#' \code{\link{GetSpatialNetwork}}
#' @param n_permutations Integer specifying number of times the labels should be randomized 
#' [default: 50]. Recommended to increase the number of permutations to >=100 for more robust
#' results. A lower number of permutations will result in high standard deviations and thus more
#' unreliable z-scores.
#' @param fixed_random_seed A logical spefiying if a fixed random seed for the permutations
#' should be used. [default: FALSE]
#' @param n_cores
#' @param verbose
#' 
#' @return A tibble with neighborhood enrichment results from permutations
#' 
#' @export
GeneratePermutedResults <- function(
    object,
    column_name,
    column_labels,
    spatnet,
    n_permutations,
    fixed_random_seed = FALSE,
    n_cores = parallel::detectCores()-1,
    verbose = TRUE
    ){
  if (verbose) cli::cli_alert_info("Generating neighborhood adjacency data from randomized labels")
  if (n_permutations < 25) {
      cli::cli_alert_warning("The number of selected permutations is low (<25). Consider increasing 'n_permutations' for more robust results")
  }

  perm_list <- parallel::mclapply(1:n_permutations, function(i){
    # if(n_permutations>200 && i%%50==0){
    #   if (verbose) cli::cli_alert_info("Iteration {i}/{n_permutations} complete")
    # } else if(i%%10==0){
    #   if (verbose) cli::cli_alert_info("Iteration {i}/{n_permutations} complete")
    # }

    if(fixed_random_seed){
      object <- randomize_label_ids(object = object,
                                    column_name = column_name,
                                    random_seed = i)
    } else {
      object <- randomize_label_ids(object = object,
                                    column_name = column_name,
                                    random_seed = NA)
    }


    # Preprocess edge table
    perm_edge_table <- spatnet |>
      add_column(
        label_1 = paste0("Label_", as.character(object[[]][spatnet$from, "perm_labels", drop = TRUE])),
        label_2 = paste0("Label_", as.character(object[[]][spatnet$to, "perm_labels", drop = TRUE]))
        )

    perm_edge_table <- perm_edge_table |>
      add_column(
        label_label = paste0(perm_edge_table$label_1, "-", perm_edge_table$label_2)
        ) |>
      filter(label_1 != label_2)


    # Count number of edges per unique label-label pair
    perm_edge_table <- perm_edge_table |>
      group_by(label_label, label_1, label_2) |>
      summarize(.groups = "keep", edges = n()) |>
      ungroup()

    # perm_edge_table <- perm_edge_table |> relocate(label_1, label_2, label_label, edges)


    # perm_nb_data <- suppressMessages(
    #   suppressWarnings(
    #     ModifiedRegionNeighbors(object = object,
    #                             column_name = "perm_labels",
    #                             spatial_network = spatnet,
    #                             column_labels = column_labels)
    #   ))
    #
    # perm_adj_mat <- CreateAdjMatrix(perm_nb_data,
    #                                 column_name = "perm_labels",
    #                                 column_labels = column_labels)
    #
    # perm_edge_table <- convert_adj_mat_to_long(perm_adj_mat)
    },
    mc.cores = n_cores,
    mc.preschedule = T
    )

  if (verbose) cli::cli_alert_success("Randomized label adjacency calculations complete")
  return(perm_list)
}
```

### RunNeighborhoodEnrichment

Neighborhood Enrichment Analysis

```{r func_test_RunNeighborhoodEnrichment, eval=F}
#' Neighborhood Enrichment Analysis
#' 
#' Performs Neighborhood Enrichment Analysis between spot labels
#'
#' @details
#' This analysis calculates the enrichment score, z-score, based on how often spots 
#' of different categorical labels (specified with \code{column_name}) lies 
#' adjacent to each other. The observed number of edges between the labels is 
#' then compared with the results from a set number of permutations (chosen 
#' with \code{n_permutations}), allowing the calculation of a z-score.
#' The z-score will indicate if a label pair is overrepresented or underrepresented
#' as compared to what would be expected to see by chance.
#' The output of this function is a tibble table that for each label pair contains
#' information about the observed number of edges (`edges`), the mean of the permuted
#' results (`perm_mean`), the standard deviation of the permuted results (`perm_sd`),
#' and the z-score (`z_score`).
#'
#' @param object A Seurat object
#' @param column_name Column name in metadata corresponding to label ID of 
#' the spots.
#' @param column_labels Optional. Provide vector of label IDs to include in your analysis. 
#' Must be more than one. Default is all (NA).
#' @param n_permutations Integer specifying number of times the labels should be randomized 
#' [default: 50]. Recommended to increase the number of permutations to >=100 for more robust
#' results. A lower number of permutations will result in high standard deviations and thus more
#' unreliable z-scores.
#' @param fixed_random_seed A logical spefiying if a fixed random seed for the permutations
#' should be used. [default: FALSE]
#' @param minK Minimum nearest neighbors when generating spatial network using the \code{\link{GetSpatialNetwork}} function [default: 0]. Spots with fewer neighbors will be 
#' discarded. Useful if you want to remove spots with few or no neighbors.
#' @param n_cores Number of cores. [default: parallel::detectCores()-1]
#' @param verbose Print messages [default: TRUE]
#'
#'
#' @import dplyr
#' @import cli
#' @importFrom tibble tibble
#' @importFrom rlang abort
#' 
#' @rdname neighborhood-enrichment
#' @family spatial-methods
#'
#' @author Lovisa Franz√©n
#' 
#'
#' @examples
#' \dontrun{
#' library(STUtility2)
#' 
#' # Read data
#' se <- readRDS(system.file("extdata/mousebrain", 
#'                           "se_mbrain", 
#'                           package = "STUtility2"))
#'                           
#' # Generate clusters
#' se <- se |>
#'   NormalizeData() |>
#'   ScaleData() |>
#'   FindVariableFeatures() |>
#'   RunPCA() |>
#'   FindNeighbors(reduction = "pca", dims = 1:30) |>
#'   FindClusters()
#' }
#' 
#' # Run Neigborhood Enrichment Analysis
#' nea_results <- RunNeighborhoodEnrichment(object = se, 
#'                                          column_name = "seurat_clusters",
#'                                          n_permutations = 100)
#' 
#' 
#' @export
RunNeighborhoodEnrichment <- function(
    object,
    column_name,
    column_labels = NA,
    n_permutations = 50,
    fixed_random_seed = FALSE,
    minK = 0,
    n_cores = parallel::detectCores()-1,
    verbose = TRUE
    ){

  # checks - import from checks.R and spatial_utils.R
  # .check_seurat_object(object)
  # .validate_column_name(object = object, column_name = column_name)

  # checks
  if (n_permutations != round(n_permutations)) rlang::abort("Invalid input for 'n_permutations', expected a numeric integer")
  if (!is.logical(fixed_random_seed)) rlang::abort("Invalid input for 'fixed_random_seed', expected a logical")

  # check column labels
  if (!is.na(column_labels[1])) {
    if (length(unique(column_labels))<=1) rlang::abort("Provided unique 'column_labels' needs to be more than 1")
    if (sum(column_labels %in% unique(object[[column_name]][,1])) < length(column_labels)) rlang::abort("Some of the provided 'column_labels' can be found among the 'column_name' labels. Please provide valid 'column_labels'")
  }

  # Start
  if (verbose) cli::cli_h2("Running Neighborhood Enrichment Analysis")
  if (verbose) cli::cli_alert_info("Generating neighborhood adjacency data from observed labels in column '{column_name}'")

  if (!is.na(column_labels[1])) {
    if (sum(duplicated(column_labels))>0) {
      cli::cli_alert_warning("Provided 'column_labels' contains duplicated values. Continuing analysis with abundant labels removed.")
      column_labels <- unique(column_labels)
    }
    if (verbose) cli::cli_alert_info("Analysis limited to study {length(column_labels)} unique labels")
  }


  # Generate spatnet
  spatnet <- do.call(bind_rows, GetSpatialNetwork(object, minK = minK, maxDist = Inf))
  spatnet$label_from <- object[[]][spatnet$from, column_name, drop = TRUE]

  # Filter spatnet if custom column_labels are provided
  if (!is.na(column_labels[1])) {
    spatnet <- subset(spatnet, label_from %in% column_labels)
  }

  # Generate weighted edge lists from region neighbors of observed labels
  # Preprocess edge table
  edge_table <- spatnet |>
    add_column(
      label_1 = paste0("Label_", as.character(object[[]][spatnet$from, column_name, drop = TRUE])),
      label_2 = paste0("Label_", as.character(object[[]][spatnet$to, column_name, drop = TRUE]))
      )
  edge_table <- edge_table |>
    add_column(
      label_label = paste0(edge_table$label_1, "-", edge_table$label_2)
      ) |>
    filter(label_1 != label_2)

  # Count number of edges per unique label-label pair
  edge_table <- edge_table |>
    group_by(label_label, label_1, label_2) |>
    summarize(.groups = "keep", edges = n()) |>
    ungroup()

  # edge_table <- edge_table |> relocate(label_1, label_2, label_label, edges)

#  nb_df <- ModifiedRegionNeighbors(object = object,
#                                   column_name = column_name,
#                                   column_labels = column_labels,
#                                   spatial_network = spatnet)
#
#  adj_mat <- CreateAdjMatrix(nb_df = nb_df,
#                             column_name = column_name,
#                             column_labels = column_labels)
#
#  edge_table <- convert_adj_mat_to_long(adj_mat = adj_mat)

  if (verbose) message("")
  if (verbose) cli::cli_alert_success("Observed label adjacency calculations complete")

  # Generate weighted edge lists from region neighbors of randomized labels
  perm_edge_list <- GeneratePermutedResults(object = object,
                                            column_name = column_name,
                                            column_labels = column_labels,
                                            spatnet = spatnet,
                                            n_permutations = n_permutations,
                                            fixed_random_seed = fixed_random_seed,
                                            n_cores = n_cores,
                                            verbose = verbose)

  # Compute mean and sd from permutations
  all_perm_edge_lists <- do.call(bind_rows, perm_edge_list)

  perm_res <- all_perm_edge_lists |>
    group_by(label_label) |>
    summarise(.groups = "keep",
              perm_mean = mean(edges),
              perm_sd = sd(edges)) |>
    ungroup()

  # perm_res <- suppressMessages(
  #   tibble(perm_edge_list[[1]][,3],
  #                    perm_mean = apply(
  #                      bind_cols(lapply(perm_edge_list, function(d){d |> select(edges)})), 1, mean
  #                      ),
  #                    perm_sd = apply(
  #                      bind_cols(lapply(perm_edge_list, function(d){d |> select(edges)})), 1, sd
  #                      )
  #                    )
  #   )

  # Prepare results output and compute z-scores
  res_out <- full_join(x = edge_table, y = perm_res, by = "label_label")
  res_out$z_score <- round((res_out$edges - res_out$perm_mean) / (res_out$perm_sd + 0.0001),
                           digits = 3)

  if (verbose) cli::cli_alert_success("Scores calculated for each label pair and returned as output tibble")

  return(res_out)
}

```

#### Build main function

Output:

```{r, eval=F}
# arguments:
object = se
column_name = "seurat_clusters"
column_labels = as.character(sort(unique(se$seurat_clusters)))
n_permutations = 100
fixed_random_seed = FALSE
minK = 0
verbose = TRUE

# checks - import from checks.R and spatial_utils.R
.check_seurat_object(object)
.validate_column_name(object, column_name)
if(!is.na(column_labels[1])){
  .validate_selected_labels
}

# checks
if (n_permutations != round(n_permutations)) abort("Invalid input for 'n_permutations', 
                                                   expected a numeric integer")
if(!is.logical(fixed_random_seed)) abort("Invalid input for 'fixed_random_seed', 
                                         expected a logical")


# function workflow
if (verbose) cli::cli_h2("Running Neighborhood Enrichment Analysis")
if (verbose) cli::cli_alert_info("Generating neighborhood adjacency data from observed labels")

# spatnet <- GetSpatialNetwork(object)
spatnet <- do.call(bind_rows, GetSpatialNetwork(object))


# nb_df <- ModifiedRegionNeighbors(object = object, 
#                                  column_name = column_name, 
#                                  column_labels = column_labels,
#                                  spatial_network = spatnet)
# 
# adj_mat <- CreateAdjMatrix(nb_df = nb_df, column_name = column_name)
edge_table <- spatnet

edge_table$label_1 <- paste0("Label_", as.character(se[[]][edge_table$from, column_name, drop = TRUE]))
edge_table$label_2 <- paste0("Label_", as.character(se[[]][edge_table$to, column_name, drop = TRUE]))

edge_table <- edge_table |> 
  group_by(label_1, label_2) |> 
  summarize(.groups = "keep", edges = n()) |> 
  ungroup()

edge_table$label_label <- paste0(edge_table$label_1, "-", edge_table$label_2)
edge_table <- edge_table |> relocate(label_1, label_2, label_label, edges)
edge_table <- edge_table[edge_table$label_1 != edge_table$label_2, ]

# edge_table <- convert_adj_mat_to_long(adj_mat = adj_mat)

if (verbose) cli::cli_alert_success("Observed label adjacency calculations complete")

perm_edge_list <- GeneratePermutedResults(object = object,
                                          spatnet = spatnet, 
                                          column_name = column_name,
                                          n_permutations = 100,
                                          fixed_random_seed = fixed_random_seed, 
                                          verbose = verbose)

all_perm_edge_lists <- do.call(bind_rows, perm_edge_list)

perm_res <- all_perm_edge_lists |> 
  group_by(label_label) |> 
  summarise(.groups = "keep", 
            perm_mean = mean(edges), 
            perm_sd = sd(edges))

res_out <- full_join(x = edge_table, y = perm_res, by = "label_label")
res_out$z_score <- round((res_out$edges - res_out$perm_mean) / res_out$perm_sd, 
                         digits = 3)

if (verbose) cli::cli_alert_success("Scores calculated for each label pair and returned as output tibble")

# return results
res_out
# return(res_out)



```

#### Functions decomposed

##### `ModifiedRegionNeighbors`

##### Generate spot network

With the function `GetSpatialNetwork` we turn the spot data into a connected network.

```{r, eval=F}
spatnet <- GetSpatialNetwork(se)

# ggplot() +
#   geom_segment(data = spatnet[[1]], aes(x = x_start, xend = x_end, y = y_start, yend = y_end)) +
#   # geom_point(data = )
#   scale_y_reverse() +
#   coord_fixed() +
#   theme_bw()
# 
# hist(spatnet[[1]]$nn)
```

##### Identify cluster neighbors

```{r, eval=F}
column_name = "seurat_clusters"
column_labels = as.character(sort(unique(se$seurat_clusters))) # c("1", "10")
# column_key <- "nb_"
#' 
#' #' Code copied from RegionNeighbors function
#' spots_list <- lapply(column_labels, function(lbl) {
#'   spots <- GetStaffli(se)@meta_data |>
#'     bind_cols(se[[]] |> select(all_of(column_name))) |>
#'     mutate_if(is.factor, as.character) |>
#'     filter(!! sym(column_name) == lbl) |>
#'     pull(barcode)
#'   }) |>
#'   setNames(column_labels)
#' 
#' #' Modified code from RegionNeighbors function
#' nbs <- setNames(lapply(names(spots_list), function(nm) {
#'   # if (verbose) cli_alert_info("Finding neighboring spots for '{nm}'")
#'   spots <- spots_list[[nm]]
#'   to_spots <- RegionNeighbors(spatnet, spots, mode = "outer")
#'   to_spots <- tibble(to_spots, nm) |>
#'     setNames(nm = c("barcode", column_name)) |>
#'     distinct()
#'   return(to_spots)
#' }), nm = column_labels)
#' 
#' # Add data to Seurat se
#' nbs_rearranged <- do.call(bind_cols, lapply(column_labels, function(lbl) {
#'   left_join(x = GetStaffli(se)@meta_data |>
#'               select(barcode) |>
#'               bind_cols(se[[]] |> select(all_of(column_name))),
#'             y = nbs[[lbl]],
#'             by = "barcode") |>
#'     select(-barcode) |>
#'     setNames(nm = c("var1", "var2")) |>
#'     mutate_if(is.factor, as.character) |>
#'     mutate(var2 = case_when((!is.na(var2)) & (var1 != var2) ~ paste0(column_key, lbl),
#'                             TRUE ~ var2)) |>
#'     select(var2) |>
#'     setNames(nm = paste0(column_key, lbl))
#' }))
```

```{r, eval=F}
# nb_data <- se@meta.data |>
#     select(contains(column_name), -contains(colnames(nbs_rearranged))) |>
#     bind_cols(nbs_rearranged)
```

##### ModifiedRegionNeighbors

```{r, eval=F}
nb_data <- ModifiedRegionNeighbors(se, column_name = column_name)

head(nb_data)
```

##### `Adjacency Matrix`

For our observed values

```{r, eval=F}
adj_mat <- CreateAdjMatrix(nb_data, column_name = column_name)
```

```{r, eval=F}
edge_table <- convert_adj_mat_to_long(adj_mat)
edge_table
```

#### Randomized values

##### Shuffle label IDs per sample

Test function

```{r, eval=F}
se <- randomize_label_ids(se, column_name = "seurat_clusters")

MapLabels(se, column_name = "seurat_clusters") | MapLabels(se, column_name = "perm_labels")
```

```{r, eval=F}
perm_nb_data <- suppressWarnings(
    ModifiedRegionNeighbors(object = se, 
                            column_name = "perm_labels", 
                            spatial_network = spatnet, 
                            column_labels = column_labels)
    )
perm_adj_mat <- CreateAdjMatrix(nb_df = perm_nb_data, column_name = "perm_labels")
perm_edge_table <- convert_adj_mat_to_long(perm_adj_mat)
```

##### Create multiple adj matrices for each iteration

```{r, eval=F}
spatnet <- GetSpatialNetwork(se)
n_permutations <- 5

res <- GeneratePermutedResults(object = se, 
                              spatnet = spatnet, 
                              n_permutations = n_permutations)
```

Summarize permuted results

```{r, eval=F}
hist(unlist(lapply(perm_list, function(d){d[1,] |> select(edges)})))
```

```{r, eval=F}
perm_res <- tibble(perm_list[[1]][,3], 
                   perm_mean = apply(
                     bind_cols(lapply(perm_list, function(d){d |> select(edges)})), 1, mean
                     ),
                   perm_sd = apply(
                     bind_cols(lapply(perm_list, function(d){d |> select(edges)})), 1, sd
                     )
                   )

perm_res
```

##### Calculate z score and add to results table

```{r, eval=F}
res_out <- full_join(x = edge_table, y = perm_res, by = "label_label")

res_out$z_score <- round((res_out$edges - res_out$perm_mean) / res_out$perm_sd, 
                         digits = 3)

# 2*pnorm(q=res_out$z_score, lower.tail=FALSE) # pvalue?

res_out
```

### 

count to-from edges

```{r, eval=F}
#' Modified code from RegionNeighbors function
nbs_outer <- setNames(lapply(names(spots_list), function(nm) {
  spots <- spots_list[[nm]]
  to_spots <- RegionNeighbors(spatnet, spots, mode = "outer")
  to_spots <- tibble(to_spots, nm) |>
    setNames(nm = c("barcode", column_name)) |>
    distinct()
  return(to_spots)
  }), nm = column_labels)

nbs_inner <- setNames(lapply(names(spots_list), function(nm) {
  spots <- spots_list[[nm]]
  to_spots <- RegionNeighbors(spatnet, spots, mode = "inner")
  to_spots <- tibble(to_spots, nm) |>
    setNames(nm = c("barcode", column_name)) |>
    distinct()
  return(to_spots)
  }), nm = column_labels)

n <- 11
nbs_outer[[n]]
nbs_inner[[n]]
spots_list[[n]]

spatnet[[1]][spatnet[[1]]$from %in% spots_list[[n]], ]

border_edges <- dplyr::filter(spatnet[[1]], from %in% spots_list[[n]] & to %in% nbs_outer[[n]]$barcode)

length(unique(border_edges$from))
length(unique(border_edges$to))
dim(border_edges)
```

```{r, eval=F}
n <- 11
ggplot() +
  geom_segment(data = spatnet[[1]], 
               aes(x = x_start, xend = x_end, y = y_start, yend = y_end)) +
  geom_point(#data = spatnet[[1]][spatnet[[1]]$from %in% nbs_outer[[n]]$barcode,], 
             data = dplyr::filter(spatnet[[1]], 
                                  from %in% spots_list[[n]] & to %in% nbs_outer[[n]]$barcode),
             mapping = aes(x = x_start, y = y_start),
             color="blue") +
  # geom_point(data = spatnet[[1]][spatnet[[1]]$from %in% nbs_inner[[n]]$barcode,], 
  #           mapping = aes(x = x_start, y = y_start),
  #           color="red") +
  scale_y_reverse() +
  coord_fixed() +
  theme_bw()
```

Count neighboring edges

```{r, eval=F}
cluster_nbs_labels


nbs_outer[[1]]

names(nbs_outer)

setNames(lapply(names(spots_list), function(nm) {
  spots <- spots_list[[nm]]
  to_spots <- RegionNeighbors(spatnet, spots, mode = "inner")
  to_spots <- tibble(to_spots, nm) |>
    setNames(nm = c("barcode", column_name)) |>
    distinct()
  return(to_spots)
  }), nm = column_labels)


GetStaffli(se)@meta_data |> select(barcode) |> bind_cols(se[[]] |> select(all_of(column_name)))

# left_join(x = GetStaffli(se)@meta_data |> select(barcode) |> 
#             bind_cols(se[[]] |> select(all_of(column_name))),
#           y = nbs[[lbl]],


# column_key <- "nb_"
# 
# nbs_rearranged <- do.call(bind_cols, lapply(column_labels, function(lbl) {
#     left_join(x = GetStaffli(se)@meta_data |>
#                 select(barcode) |>
#                 bind_cols(se[[]] |> select(all_of(column_name))),
#               y = nbs[[lbl]],
#               by = "barcode") |>
#       select(-barcode) |>
#       setNames(nm = c("var1", "var2")) |>
#       mutate_if(is.factor, as.character) |>
#       mutate(var2 = case_when((!is.na(var2)) & (var1 != var2) ~ paste0(column_key, lbl),
#                               TRUE ~ var2)) |>
#       select(var2) |>
#       setNames(nm = paste0(column_key, lbl))
#   }))
```
