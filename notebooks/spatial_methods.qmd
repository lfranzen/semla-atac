---
title: "Spatial methods"
format: html
editor: visual
---

## Introduction

In this notebook, we'll have a look at how you can use spatial methods in `STUtility2`.

```{r}
library(tibble)
library(ggplot2)
library(patchwork)
library(STUtility2)
library(scico)
```

## Load data

First we need to load some 10x Visium data. here we'll use a breast cancer dataset provided by 10x

```{r}
samples <- Sys.glob("~/BC_data/*/filtered_feature_bc_matrix.h5")
imgs <- Sys.glob("~/BC_data/*/spatial/tissue_hires_image.png")
spotfiles <- Sys.glob("~/BC_data/*/spatial/tissue_positions_list.csv")
json <- Sys.glob("~/BC_data/*/spatial/scalefactors_json.json")

# Create a tibble/data.frame with file paths
infoTable <- tibble(samples, imgs, spotfiles, json, sample_id = c("S1", "S2"))

# Create Seurat object
se <- ReadVisiumData(infoTable = infoTable[1, ])
```

## Data 

Next, we'll use `Seurat` to run a simple data processing/analysis workflow:

-   normalize data

-   scale data

-   find variable features

-   run dimensionality reduction by PCA

-   Create SNN graph

-   Cluster data

```{r message=FALSE, warning=FALSE}
se <- se |>
  NormalizeData() |>
  ScaleData() |>
  FindVariableFeatures() |>
  RunPCA() |>
  FindNeighbors(reduction = "pca", dims = 1:30) |>
  FindClusters()
```

Now that we have identified clusters in our data based on the spot expression profiles, we can plot these clusters spatially with `MapLabels`.

```{r}
se <- LoadImages(se)
MapLabels(se, column_name = "seurat_clusters", override_plot_dims = TRUE, 
          image_use = "raw", pt_alpha = 0.6) +
  plot_layout(guides = "collect") &
  theme(legend.position = "right") &
  guides(fill = guide_legend(override.aes = list(size = 3), ncol = 2))
```

For the purpose of this analysis, we just need to define a region of interest in our tissue sections. We could just as well use the tissue morphology as a basis to define this region. From the plot above, we can see that some clusters are confined to distinct regions, for example cluster 9:

```{r}
se$cluster_9 <- ifelse(se$seurat_clusters %in% "9", "9", NA)
MapLabels(se, column_name = "cluster_9", override_plot_dims = TRUE, 
          image_use = "raw", drop_na = TRUE) +
  plot_layout(guides = "collect") &
  theme(legend.position = "right") &
  guides(fill = guide_legend(override.aes = list(size = 3), ncol = 2))
```

## Disconnect regions

Cluster 9 is concentrated to a region rich with cancer cells but there are also a few spots in other parts of the tissue. At this point we might only be interested in one of these regions in which case we can split cluster_9 into spatially disconnected compartments. For this purpose, we can use `DisconnectRegions`:

```{r}
se <- DisconnectRegions(se, column_name = "seurat_clusters", sel_groups = "9")

MapLabels(se, column_name = "9_split", override_plot_dims = TRUE, 
          image_use = "raw", drop_na = TRUE) +
  plot_layout(guides = "collect") &
  theme(legend.position = "right") &
  guides(fill = guide_legend(override.aes = list(size = 3), ncol = 2))
```

Each spatially disconnected region in cluster 9 now has its own label, order from largest to smallest. Singletons are spots that are completely isolated from other spots with the same label.

## Radial distance

Imagine that we are interested in looking at the expression of certain genes as a function of distance to a region of interest. We can compute distances from a region of interest (ROI) using `RadialDistances`. Here we'll use cluster 3 as our ROI for the computation:

```{r}
se <- RadialDistance(se, column_name = "seurat_clusters", sel_groups = "3")
```

We can illustrate the results by coloring the spots based on the radial distances from "S1_region1":

```{r fig.width=2, fig.height=2}
MapFeatures(se, features = "r_dist_3", center_zero = TRUE, 
            colors = RColorBrewer::brewer.pal(n = 11, name = "RdBu") |> rev(),
            override_plot_dims = TRUE)
```

The distances are calculated from the border of the ROI, where positive values represent the radial distances out from the ROI and negative values represent the radial distances towards the center of the ROI.

The distances are given as pixels relative to the image pixels coordinates that were loaded when creating the `Seurat` object. If we know the conversion factor between pixels in our original H&E image and microns, we can easily convert the radial distances to microns. In this example data, the center-to-center spot distance is 273 pixels in the image and we know that the actual center-to-center spot distance is 100 microns.

```{r}
se$r_dist_3 <- (100/273)*se$r_dist_3
```

The scale of the distances is somewhat inconvenient for our color scale, so we can apply some transformation to make them easier to visualize, for example the square root of the distance:

```{r fig.width=2, fig.height=2}
se$r_dist_3_sqrt <- sign(se$r_dist_3)*sqrt(abs(se$r_dist_3))
MapFeatures(se, features = "r_dist_3_sqrt", center_zero = TRUE, 
            colors = RColorBrewer::brewer.pal(n = 11, name = "RdBu") |> rev(),
            override_plot_dims = TRUE)
```

With these distances, we can now explore the expression of certain genes as a function of distance from our ROI. Here we are only interested in the microenvironment outside of our cluster 3, so we will filter the data to have a maximum radial distance of 1000 microns outside of cluster 3:

```{r}
sel_genes <- c("CRISP3", "IGLC2")

se[[]] |> 
  bind_cols(FetchData(se, vars = sel_genes)) |> 
  filter(r_dist_3 < 1e3) |> 
  pivot_longer(all_of(sel_genes), names_to = "variable", values_to = "value") |> 
  ggplot(aes(r_dist_3, value, color = variable)) +
    geom_smooth(method = "gam", formula = y ~ s(x, bs = "cs")) +
    geom_vline(aes(xintercept = 0, color = "border"), linetype = "dashed")
```

Here we can see that the expression of CRISP3 is high inside cluster 3 and declines rapidly at the border whereas IGLC2 show the opposite trend. We can also visualize these trends spatially:

```{r}
MapFeatures(SubsetSTData(se, expression = r_dist_3 < 1e3), 
            features = sel_genes, override_plot_dims = TRUE, scale_alpha = TRUE,
            image_use = "raw", pt_size = 2)
```

So why bother using radial distances? Having access to this information makes it possible to identify genes that change with distance to a ROI. In the example above, we could for example identify genes whose expression decrease or increase expression distance from the tumor which gives us a useful tool to characterize the tumor microenvironment. A perhaps even more useful application is to explore the relative abundance of cell types around or inside the tumor border.
